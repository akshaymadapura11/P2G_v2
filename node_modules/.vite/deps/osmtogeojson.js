import {
  __commonJS
} from "./chunk-2GTGKKMZ.js";

// node_modules/osmtogeojson/lodash.custom.js
var require_lodash_custom = __commonJS({
  "node_modules/osmtogeojson/lodash.custom.js"(exports, module) {
    (function() {
      var undefined2;
      var VERSION = "4.15.0";
      var LARGE_ARRAY_SIZE = 200;
      var FUNC_ERROR_TEXT = "Expected a function";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var UNORDERED_COMPARE_FLAG = 1, PARTIAL_COMPARE_FLAG = 2;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991;
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", promiseTag = "[object Promise]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, reLeadingDot = /^\./, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      var reEscapeChar = /\\(\\)?/g;
      var reFlags = /\w*$/;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          return freeProcess && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function addMapEntry(map, pair) {
        map.set(pair[0], pair[1]);
        return map;
      }
      function addSetEntry(set, value) {
        set.add(value);
        return set;
      }
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayEach(array, iteratee2) {
        var index = -1, length = array ? array.length : 0;
        while (++index < length) {
          if (iteratee2(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
      function arrayReduce(array, iteratee2, accumulator, initAccum) {
        var index = -1, length = array ? array.length : 0;
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee2(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index = -1, length = array ? array.length : 0;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined2 : object[key];
        };
      }
      function baseTimes(n, iteratee2) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee2(index);
        }
        return result;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function getValue(object, key) {
        return object == null ? undefined2 : object[key];
      }
      function isHostObject(value) {
        var result = false;
        if (value != null && typeof value.toString != "function") {
          try {
            result = !!(value + "");
          } catch (e) {
          }
        }
        return result;
      }
      function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function setToArray(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
      var coreJsData = root["__core-js_shared__"];
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      var funcToString = funcProto.toString;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var objectCtorString = funcToString.call(Object);
      var objectToString = objectProto.toString;
      var reIsNative = RegExp(
        "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      var Buffer = moduleExports ? root.Buffer : undefined2, Symbol = root.Symbol, Uint8Array = root.Uint8Array, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice;
      var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined2, nativeKeys = overArg(Object.keys, Object), nativeMax = Math.max;
      var DataView = getNative(root, "DataView"), Map = getNative(root, "Map"), Promise2 = getNative(root, "Promise"), Set = getNative(root, "Set"), WeakMap = getNative(root, "WeakMap"), nativeCreate = getNative(Object, "create");
      var nonEnumShadows = !propertyIsEnumerable.call({ "valueOf": 1 }, "valueOf");
      var realNames = {};
      var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
      var symbolProto = Symbol ? Symbol.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
      function lodash() {
      }
      function Hash(entries) {
        var index = -1, length = entries ? entries.length : 0;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
      }
      function hashDelete(key) {
        return this.has(key) && delete this.__data__[key];
      }
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result = data[key];
          return result === HASH_UNDEFINED ? undefined2 : result;
        }
        return hasOwnProperty.call(data, key) ? data[key] : undefined2;
      }
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
      }
      function hashSet(key, value) {
        var data = this.__data__;
        data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
        return this;
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index = -1, length = entries ? entries.length : 0;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
      }
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? undefined2 : data[index][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index = -1, length = entries ? entries.length : 0;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map || ListCache)(),
          "string": new Hash()
        };
      }
      function mapCacheDelete(key) {
        return getMapData(this, key)["delete"](key);
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        getMapData(this, key).set(key, value);
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function SetCache(values) {
        var index = -1, length = values ? values.length : 0;
        this.__data__ = new MapCache();
        while (++index < length) {
          this.add(values[index]);
        }
      }
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack(entries) {
        this.__data__ = new ListCache(entries);
      }
      function stackClear() {
        this.__data__ = new ListCache();
      }
      function stackDelete(key) {
        return this.__data__["delete"](key);
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      function stackSet(key, value) {
        var cache = this.__data__;
        if (cache instanceof ListCache) {
          var pairs = cache.__data__;
          if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            return this;
          }
          cache = this.__data__ = new MapCache(pairs);
        }
        cache.set(key, value);
        return this;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function arrayLikeKeys(value, inherited) {
        var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
        var length = result.length, skipIndexes = !!length;
        for (var key in value) {
          if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
            result.push(key);
          }
        }
        return result;
      }
      function assignMergeValue(object, key, value) {
        if (value !== undefined2 && !eq(object[key], value) || typeof key == "number" && value === undefined2 && !(key in object)) {
          object[key] = value;
        }
      }
      function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
          object[key] = value;
        }
      }
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      function baseAssign(object, source) {
        return object && copyObject(source, keys(source), object);
      }
      function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
        var result;
        if (customizer) {
          result = object ? customizer(value, key, object, stack) : customizer(value);
        }
        if (result !== undefined2) {
          return result;
        }
        if (!isObject(value)) {
          return value;
        }
        var isArr = isArray(value);
        if (isArr) {
          result = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result);
          }
        } else {
          var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag || tag == argsTag || isFunc && !object) {
            if (isHostObject(value)) {
              return object ? value : {};
            }
            result = initCloneObject(isFunc ? {} : value);
            if (!isDeep) {
              return copySymbols(value, baseAssign(result, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object ? value : {};
            }
            result = initCloneByTag(value, tag, baseClone, isDeep);
          }
        }
        stack || (stack = new Stack());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result);
        if (!isArr) {
          var props = isFull ? getAllKeys(value) : keys(value);
        }
        arrayEach(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue(result, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value, stack));
        });
        return result;
      }
      function baseCreate(proto) {
        return isObject(proto) ? objectCreate(proto) : {};
      }
      var baseEach = createBaseEach(baseForOwn);
      var baseFor = createBaseFor();
      function baseForOwn(object, iteratee2) {
        return object && baseFor(object, iteratee2, keys);
      }
      function baseGet(object, path) {
        path = isKey(path, object) ? [path] : castPath(path);
        var index = 0, length = path.length;
        while (object != null && index < length) {
          object = object[toKey(path[index++])];
        }
        return index && index == length ? object : undefined2;
      }
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result = keysFunc(object);
        return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
      }
      function baseGetTag(value) {
        return objectToString.call(value);
      }
      function baseHasIn(object, key) {
        return object != null && key in Object(object);
      }
      function baseIsEqual(value, other, customizer, bitmask, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
      }
      function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
        var objIsArr = isArray(object), othIsArr = isArray(other), objTag = arrayTag, othTag = arrayTag;
        if (!objIsArr) {
          objTag = getTag(object);
          objTag = objTag == argsTag ? objectTag : objTag;
        }
        if (!othIsArr) {
          othTag = getTag(other);
          othTag = othTag == argsTag ? objectTag : othTag;
        }
        var objIsObj = objTag == objectTag && !isHostObject(object), othIsObj = othTag == objectTag && !isHostObject(other), isSameTag = objTag == othTag;
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack());
          return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
        }
        if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack());
        return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
      }
      function baseIsMatch(object, source, matchData, customizer) {
        var index = matchData.length, length = index, noCustomizer = !customizer;
        if (object == null) {
          return !length;
        }
        object = Object(object);
        while (index--) {
          var data = matchData[index];
          if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
            return false;
          }
        }
        while (++index < length) {
          data = matchData[index];
          var key = data[0], objValue = object[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === undefined2 && !(key in object)) {
              return false;
            }
          } else {
            var stack = new Stack();
            if (customizer) {
              var result = customizer(objValue, srcValue, key, object, source, stack);
            }
            if (!(result === undefined2 ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
              return false;
            }
          }
        }
        return true;
      }
      function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity;
        }
        if (typeof value == "object") {
          return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result = [];
        for (var key in Object(object)) {
          if (hasOwnProperty.call(object, key) && key != "constructor") {
            result.push(key);
          }
        }
        return result;
      }
      function baseKeysIn(object) {
        if (!isObject(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
            result.push(key);
          }
        }
        return result;
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object) {
          var objValue = get(object, path);
          return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, undefined2, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
        };
      }
      function baseMerge(object, source, srcIndex, customizer, stack) {
        if (object === source) {
          return;
        }
        if (!(isArray(source) || isTypedArray(source))) {
          var props = baseKeysIn(source);
        }
        arrayEach(props || source, function(srcValue, key) {
          if (props) {
            key = srcValue;
            srcValue = source[key];
          }
          if (isObject(srcValue)) {
            stack || (stack = new Stack());
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(object[key], srcValue, key + "", object, source, stack) : undefined2;
            if (newValue === undefined2) {
              newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
          }
        });
      }
      function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = object[key], srcValue = source[key], stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
        var isCommon = newValue === undefined2;
        if (isCommon) {
          newValue = srcValue;
          if (isArray(srcValue) || isTypedArray(srcValue)) {
            if (isArray(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else {
              isCommon = false;
              newValue = baseClone(srcValue, true);
            }
          } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject(objValue) || srcIndex && isFunction(objValue)) {
              isCommon = false;
              newValue = baseClone(srcValue, true);
            } else {
              newValue = objValue;
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object, key, newValue);
      }
      function basePropertyDeep(path) {
        return function(object) {
          return baseGet(object, path);
        };
      }
      function baseRest(func, start) {
        start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
        return function() {
          var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
          while (++index < length) {
            array[index] = args[start + index];
          }
          index = -1;
          var otherArgs = Array(start + 1);
          while (++index < start) {
            otherArgs[index] = args[index];
          }
          otherArgs[start] = array;
          return apply(func, this, otherArgs);
        };
      }
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      function castPath(value) {
        return isArray(value) ? value : stringToPath(value);
      }
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var result = new buffer.constructor(buffer.length);
        buffer.copy(result);
        return result;
      }
      function cloneArrayBuffer(arrayBuffer) {
        var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array(result).set(new Uint8Array(arrayBuffer));
        return result;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      function cloneMap(map, isDeep, cloneFunc) {
        var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
        return arrayReduce(array, addMapEntry, new map.constructor());
      }
      function cloneRegExp(regexp) {
        var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result.lastIndex = regexp.lastIndex;
        return result;
      }
      function cloneSet(set, isDeep, cloneFunc) {
        var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
        return arrayReduce(array, addSetEntry, new set.constructor());
      }
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      function copyArray(source, array) {
        var index = -1, length = source.length;
        array || (array = Array(length));
        while (++index < length) {
          array[index] = source[index];
        }
        return array;
      }
      function copyObject(source, props, object, customizer) {
        object || (object = {});
        var index = -1, length = props.length;
        while (++index < length) {
          var key = props[index];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
          assignValue(object, key, newValue === undefined2 ? source[key] : newValue);
        }
        return object;
      }
      function copySymbols(source, object) {
        return copyObject(source, getSymbols(source), object);
      }
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined2 : customizer;
            length = 1;
          }
          object = Object(object);
          while (++index < length) {
            var source = sources[index];
            if (source) {
              assigner(object, source, index, customizer);
            }
          }
          return object;
        });
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee2) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee2);
          }
          var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
          while (fromRight ? index-- : ++index < length) {
            if (iteratee2(iterable[index], index, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      function createBaseFor(fromRight) {
        return function(object, iteratee2, keysFunc) {
          var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index];
            if (iteratee2(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
        var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var stacked = stack.get(array);
        if (stacked && stack.get(other)) {
          return stacked == other;
        }
        var index = -1, result = true, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : undefined2;
        stack.set(array, other);
        stack.set(other, array);
        while (++index < arrLength) {
          var arrValue = array[index], othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
          }
          if (compared !== undefined2) {
            if (compared) {
              continue;
            }
            result = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!seen.has(othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, customizer, bitmask, stack))) {
                return seen.add(othIndex);
              }
            })) {
              result = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
            result = false;
            break;
          }
        }
        stack["delete"](array);
        stack["delete"](other);
        return result;
      }
      function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= UNORDERED_COMPARE_FLAG;
            stack.set(object, other);
            var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
            stack["delete"](object);
            return result;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
        var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
            return false;
          }
        }
        var stacked = stack.get(object);
        if (stacked && stack.get(other)) {
          return stacked == other;
        }
        var result = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
          }
          if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
            result = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result = false;
          }
        }
        stack["delete"](object);
        stack["delete"](other);
        return result;
      }
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys, getSymbols);
      }
      function getIteratee() {
        var result = lodash.iteratee || iteratee;
        result = result === iteratee ? baseIteratee : result;
        return arguments.length ? result(arguments[0], arguments[1]) : result;
      }
      function getMapData(map, key) {
        var data = map.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function getMatchData(object) {
        var result = keys(object), length = result.length;
        while (length--) {
          var key = result[length], value = object[key];
          result[length] = [key, value, isStrictComparable(value)];
        }
        return result;
      }
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : undefined2;
      }
      var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
      var getTag = baseGetTag;
      if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
        getTag = function(value) {
          var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : undefined2;
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result;
        };
      }
      function hasPath(object, path, hasFunc) {
        path = isKey(path, object) ? [path] : castPath(path);
        var result, index = -1, length = path.length;
        while (++index < length) {
          var key = toKey(path[index]);
          if (!(result = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result) {
          return result;
        }
        var length = object ? object.length : 0;
        return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
      }
      function initCloneArray(array) {
        var length = array.length, result = array.constructor(length);
        if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
          result.index = array.index;
          result.input = array.input;
        }
        return result;
      }
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }
      function initCloneByTag(object, tag, cloneFunc, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object);
          case boolTag:
          case dateTag:
            return new Ctor(+object);
          case dataViewTag:
            return cloneDataView(object, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object, isDeep);
          case mapTag:
            return cloneMap(object, isDeep, cloneFunc);
          case numberTag:
          case stringTag:
            return new Ctor(object);
          case regexpTag:
            return cloneRegExp(object);
          case setTag:
            return cloneSet(object, isDeep, cloneFunc);
          case symbolTag:
            return cloneSymbol(object);
        }
      }
      function isIndex(value, length) {
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function isIterateeCall(value, index, object) {
        if (!isObject(object)) {
          return false;
        }
        var type = typeof index;
        if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
          return eq(object[index], value);
        }
        return false;
      }
      function isKey(value, object) {
        if (isArray(value)) {
          return false;
        }
        var type = typeof value;
        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
      }
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto;
      }
      function isStrictComparable(value) {
        return value === value && !isObject(value);
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== undefined2 || key in Object(object));
        };
      }
      function nativeKeysIn(object) {
        var result = [];
        if (object != null) {
          for (var key in Object(object)) {
            result.push(key);
          }
        }
        return result;
      }
      var stringToPath = memoize(function(string) {
        string = toString(string);
        var result = [];
        if (reLeadingDot.test(string)) {
          result.push("");
        }
        string.replace(rePropName, function(match, number, quote, string2) {
          result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
        });
        return result;
      });
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      function compact(array) {
        var index = -1, length = array ? array.length : 0, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (value) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function forEach(collection, iteratee2) {
        var func = isArray(collection) ? arrayEach : baseEach;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver && typeof resolver != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result = func.apply(this, args);
          memoized.cache = cache.set(key, result);
          return result;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      function clone(value) {
        return baseClone(value, false, true);
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      function isArguments(value) {
        return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
      }
      var isArray = Array.isArray;
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      var isBuffer = nativeIsBuffer || stubFalse;
      function isEmpty(value) {
        if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isArguments(value))) {
          return !value.length;
        }
        var tag = getTag(value);
        if (tag == mapTag || tag == setTag) {
          return !value.size;
        }
        if (nonEnumShadows || isPrototype(value)) {
          return !nativeKeys(value).length;
        }
        for (var key in value) {
          if (hasOwnProperty.call(value, key)) {
            return false;
          }
        }
        return true;
      }
      function isFunction(value) {
        var tag = isObject(value) ? objectToString.call(value) : "";
        return tag == funcTag || tag == genTag;
      }
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isObject(value) {
        var type = typeof value;
        return !!value && (type == "object" || type == "function");
      }
      function isObjectLike(value) {
        return !!value && typeof value == "object";
      }
      function isPlainObject(value) {
        if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
          return false;
        }
        var proto = getPrototype(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
      }
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function toString(value) {
        return value == null ? "" : baseToString(value);
      }
      function get(object, path, defaultValue) {
        var result = object == null ? undefined2 : baseGet(object, path);
        return result === undefined2 ? defaultValue : result;
      }
      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
      }
      function keys(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      var merge = createAssigner(function(object, source, srcIndex) {
        baseMerge(object, source, srcIndex);
      });
      function identity(value) {
        return value;
      }
      function iteratee(func) {
        return baseIteratee(typeof func == "function" ? func : baseClone(func, true));
      }
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      function stubArray() {
        return [];
      }
      function stubFalse() {
        return false;
      }
      lodash.compact = compact;
      lodash.iteratee = iteratee;
      lodash.keys = keys;
      lodash.keysIn = keysIn;
      lodash.memoize = memoize;
      lodash.merge = merge;
      lodash.property = property;
      lodash.toPlainObject = toPlainObject;
      lodash.clone = clone;
      lodash.eq = eq;
      lodash.forEach = forEach;
      lodash.get = get;
      lodash.hasIn = hasIn;
      lodash.identity = identity;
      lodash.isArguments = isArguments;
      lodash.isArray = isArray;
      lodash.isArrayLike = isArrayLike;
      lodash.isArrayLikeObject = isArrayLikeObject;
      lodash.isBuffer = isBuffer;
      lodash.isEmpty = isEmpty;
      lodash.isFunction = isFunction;
      lodash.isLength = isLength;
      lodash.isObject = isObject;
      lodash.isObjectLike = isObjectLike;
      lodash.isPlainObject = isPlainObject;
      lodash.isSymbol = isSymbol;
      lodash.isTypedArray = isTypedArray;
      lodash.stubArray = stubArray;
      lodash.stubFalse = stubFalse;
      lodash.toString = toString;
      lodash.each = forEach;
      lodash.VERSION = VERSION;
      if (freeModule) {
        (freeModule.exports = lodash)._ = lodash;
        freeExports._ = lodash;
      }
    }).call(exports);
  }
});

// node_modules/@mapbox/geojson-rewind/index.js
var require_geojson_rewind = __commonJS({
  "node_modules/@mapbox/geojson-rewind/index.js"(exports, module) {
    module.exports = rewind;
    function rewind(gj, outer) {
      var type = gj && gj.type, i;
      if (type === "FeatureCollection") {
        for (i = 0; i < gj.features.length; i++)
          rewind(gj.features[i], outer);
      } else if (type === "GeometryCollection") {
        for (i = 0; i < gj.geometries.length; i++)
          rewind(gj.geometries[i], outer);
      } else if (type === "Feature") {
        rewind(gj.geometry, outer);
      } else if (type === "Polygon") {
        rewindRings(gj.coordinates, outer);
      } else if (type === "MultiPolygon") {
        for (i = 0; i < gj.coordinates.length; i++)
          rewindRings(gj.coordinates[i], outer);
      }
      return gj;
    }
    function rewindRings(rings, outer) {
      if (rings.length === 0)
        return;
      rewindRing(rings[0], outer);
      for (var i = 1; i < rings.length; i++) {
        rewindRing(rings[i], !outer);
      }
    }
    function rewindRing(ring, dir) {
      var area = 0, err = 0;
      for (var i = 0, len = ring.length, j = len - 1; i < len; j = i++) {
        var k = (ring[i][0] - ring[j][0]) * (ring[j][1] + ring[i][1]);
        var m = area + k;
        err += Math.abs(area) >= Math.abs(k) ? area - m + k : k - m + area;
        area = m;
      }
      if (area + err >= 0 !== !!dir)
        ring.reverse();
    }
  }
});

// node_modules/osm-polygon-features/polygon-features.json
var require_polygon_features = __commonJS({
  "node_modules/osm-polygon-features/polygon-features.json"(exports, module) {
    module.exports = [
      {
        key: "building",
        polygon: "all"
      },
      {
        key: "highway",
        polygon: "whitelist",
        values: [
          "services",
          "rest_area",
          "escape",
          "elevator"
        ]
      },
      {
        key: "natural",
        polygon: "blacklist",
        values: [
          "coastline",
          "cliff",
          "ridge",
          "arete",
          "tree_row"
        ]
      },
      {
        key: "landuse",
        polygon: "all"
      },
      {
        key: "waterway",
        polygon: "whitelist",
        values: [
          "riverbank",
          "dock",
          "boatyard",
          "dam"
        ]
      },
      {
        key: "amenity",
        polygon: "all"
      },
      {
        key: "leisure",
        polygon: "all"
      },
      {
        key: "barrier",
        polygon: "whitelist",
        values: [
          "city_wall",
          "ditch",
          "hedge",
          "retaining_wall",
          "wall",
          "spikes"
        ]
      },
      {
        key: "railway",
        polygon: "whitelist",
        values: [
          "station",
          "turntable",
          "roundhouse",
          "platform"
        ]
      },
      {
        key: "area",
        polygon: "all"
      },
      {
        key: "boundary",
        polygon: "all"
      },
      {
        key: "man_made",
        polygon: "blacklist",
        values: [
          "cutline",
          "embankment",
          "pipeline"
        ]
      },
      {
        key: "power",
        polygon: "whitelist",
        values: [
          "plant",
          "substation",
          "generator",
          "transformer"
        ]
      },
      {
        key: "place",
        polygon: "all"
      },
      {
        key: "shop",
        polygon: "all"
      },
      {
        key: "aeroway",
        polygon: "blacklist",
        values: [
          "taxiway"
        ]
      },
      {
        key: "tourism",
        polygon: "all"
      },
      {
        key: "historic",
        polygon: "all"
      },
      {
        key: "public_transport",
        polygon: "all"
      },
      {
        key: "office",
        polygon: "all"
      },
      {
        key: "building:part",
        polygon: "all"
      },
      {
        key: "military",
        polygon: "all"
      },
      {
        key: "ruins",
        polygon: "all"
      },
      {
        key: "area:highway",
        polygon: "all"
      },
      {
        key: "craft",
        polygon: "all"
      },
      {
        key: "golf",
        polygon: "all"
      },
      {
        key: "indoor",
        polygon: "all"
      }
    ];
  }
});

// node_modules/osm-polygon-features/index.js
var require_osm_polygon_features = __commonJS({
  "node_modules/osm-polygon-features/index.js"(exports, module) {
    module.exports = require_polygon_features();
  }
});

// node_modules/osmtogeojson/index.js
var require_osmtogeojson = __commonJS({
  "node_modules/osmtogeojson/index.js"(exports, module) {
    var _ = require_lodash_custom();
    var rewind = require_geojson_rewind();
    var polygonFeatures = {};
    require_osm_polygon_features().forEach(function(tags) {
      if (tags.polygon === "all")
        polygonFeatures[tags.key] = true;
      else {
        var list = tags.polygon === "whitelist" ? "included_values" : "excluded_values", tagValuesObj = {};
        tags.values.forEach(function(value) {
          tagValuesObj[value] = true;
        });
        polygonFeatures[tags.key] = {};
        polygonFeatures[tags.key][list] = tagValuesObj;
      }
    });
    function default_deduplicator(objectA, objectB) {
      if ((objectA.version || objectB.version) && objectA.version !== objectB.version) {
        return (+objectA.version || 0) > (+objectB.version || 0) ? objectA : objectB;
      }
      return _.merge(objectA, objectB);
    }
    var osmtogeojson = {};
    osmtogeojson = function(data, options, featureCallback) {
      options = _.merge(
        {
          verbose: false,
          flatProperties: true,
          uninterestingTags: {
            "source": true,
            "source_ref": true,
            "source:ref": true,
            "history": true,
            "attribution": true,
            "created_by": true,
            "tiger:county": true,
            "tiger:tlid": true,
            "tiger:upload_uuid": true
          },
          polygonFeatures,
          deduplicator: default_deduplicator
        },
        options
      );
      var result;
      if (typeof XMLDocument !== "undefined" && data instanceof XMLDocument || typeof XMLDocument === "undefined" && data.childNodes)
        result = _osmXML2geoJSON(data);
      else
        result = _overpassJSON2geoJSON(data);
      return result;
      function _overpassJSON2geoJSON(json) {
        var nodes = new Array();
        var ways = new Array();
        var rels = new Array();
        function centerGeometry(object) {
          var pseudoNode = _.clone(object);
          pseudoNode.lat = object.center.lat;
          pseudoNode.lon = object.center.lon;
          pseudoNode.__is_center_placeholder = true;
          nodes.push(pseudoNode);
        }
        function boundsGeometry(object) {
          var pseudoWay = _.clone(object);
          pseudoWay.nodes = [];
          function addPseudoNode(lat, lon, i2) {
            var pseudoNode = {
              type: "node",
              id: "_" + pseudoWay.type + "/" + pseudoWay.id + "bounds" + i2,
              lat,
              lon
            };
            pseudoWay.nodes.push(pseudoNode.id);
            nodes.push(pseudoNode);
          }
          addPseudoNode(pseudoWay.bounds.minlat, pseudoWay.bounds.minlon, 1);
          addPseudoNode(pseudoWay.bounds.maxlat, pseudoWay.bounds.minlon, 2);
          addPseudoNode(pseudoWay.bounds.maxlat, pseudoWay.bounds.maxlon, 3);
          addPseudoNode(pseudoWay.bounds.minlat, pseudoWay.bounds.maxlon, 4);
          pseudoWay.nodes.push(pseudoWay.nodes[0]);
          pseudoWay.__is_bounds_placeholder = true;
          ways.push(pseudoWay);
        }
        function fullGeometryWay(way2) {
          function addFullGeometryNode(lat, lon, id) {
            var geometryNode = {
              type: "node",
              id,
              lat,
              lon
            };
            nodes.push(geometryNode);
          }
          if (!_.isArray(way2.nodes)) {
            way2.nodes = way2.geometry.map(function(nd) {
              if (nd !== null)
                return "_anonymous@" + nd.lat + "/" + nd.lon;
              else
                return "_anonymous@unknown_location";
            });
          }
          way2.geometry.forEach(function(nd, i2) {
            if (nd) {
              addFullGeometryNode(
                nd.lat,
                nd.lon,
                way2.nodes[i2]
              );
            }
          });
        }
        function fullGeometryRelation(rel2) {
          function addFullGeometryNode(lat, lon, id) {
            var geometryNode = {
              type: "node",
              id,
              lat,
              lon
            };
            nodes.push(geometryNode);
          }
          function addFullGeometryWay(geometry, id) {
            if (ways.some(function(way2) {
              return way2.type == "way" && way2.id == id;
            }))
              return;
            var geometryWay = {
              type: "way",
              id,
              nodes: []
            };
            function addFullGeometryWayPseudoNode(lat, lon) {
              var geometryPseudoNode = {
                type: "node",
                id: "_anonymous@" + lat + "/" + lon,
                lat,
                lon
              };
              geometryWay.nodes.push(geometryPseudoNode.id);
              nodes.push(geometryPseudoNode);
            }
            geometry.forEach(function(nd) {
              if (nd) {
                addFullGeometryWayPseudoNode(
                  nd.lat,
                  nd.lon
                );
              } else {
                geometryWay.nodes.push(void 0);
              }
            });
            ways.push(geometryWay);
          }
          rel2.members.forEach(function(member, i2) {
            if (member.type == "node") {
              if (member.lat) {
                addFullGeometryNode(
                  member.lat,
                  member.lon,
                  member.ref
                );
              }
            } else if (member.type == "way") {
              if (member.geometry) {
                member.ref = "_fullGeom" + member.ref;
                addFullGeometryWay(
                  member.geometry,
                  member.ref
                );
              }
            }
          });
        }
        for (var i = 0; i < json.elements.length; i++) {
          switch (json.elements[i].type) {
            case "node":
              var node = json.elements[i];
              nodes.push(node);
              break;
            case "way":
              var way = _.clone(json.elements[i]);
              way.nodes = _.clone(way.nodes);
              ways.push(way);
              if (way.center)
                centerGeometry(way);
              if (way.geometry)
                fullGeometryWay(way);
              else if (way.bounds)
                boundsGeometry(way);
              break;
            case "relation":
              var rel = _.clone(json.elements[i]);
              rel.members = _.clone(rel.members);
              rels.push(rel);
              var has_full_geometry = rel.members && rel.members.some(function(member) {
                return member.type == "node" && member.lat || member.type == "way" && member.geometry && member.geometry.length > 0;
              });
              if (rel.center)
                centerGeometry(rel);
              if (has_full_geometry)
                fullGeometryRelation(rel);
              else if (rel.bounds)
                boundsGeometry(rel);
              break;
            default:
          }
        }
        return _convert2geoJSON(nodes, ways, rels);
      }
      function _osmXML2geoJSON(xml) {
        var nodes = new Array();
        var ways = new Array();
        var rels = new Array();
        function copy_attribute(x, o, attr) {
          if (x.hasAttribute(attr))
            o[attr] = x.getAttribute(attr);
        }
        function centerGeometry(object, centroid2) {
          var pseudoNode = _.clone(object);
          copy_attribute(centroid2, pseudoNode, "lat");
          copy_attribute(centroid2, pseudoNode, "lon");
          pseudoNode.__is_center_placeholder = true;
          nodes.push(pseudoNode);
        }
        function boundsGeometry(object, bounds2) {
          var pseudoWay = _.clone(object);
          pseudoWay.nodes = [];
          function addPseudoNode(lat, lon, i) {
            var pseudoNode = {
              type: "node",
              id: "_" + pseudoWay.type + "/" + pseudoWay.id + "bounds" + i,
              lat,
              lon
            };
            pseudoWay.nodes.push(pseudoNode.id);
            nodes.push(pseudoNode);
          }
          addPseudoNode(bounds2.getAttribute("minlat"), bounds2.getAttribute("minlon"), 1);
          addPseudoNode(bounds2.getAttribute("maxlat"), bounds2.getAttribute("minlon"), 2);
          addPseudoNode(bounds2.getAttribute("maxlat"), bounds2.getAttribute("maxlon"), 3);
          addPseudoNode(bounds2.getAttribute("minlat"), bounds2.getAttribute("maxlon"), 4);
          pseudoWay.nodes.push(pseudoWay.nodes[0]);
          pseudoWay.__is_bounds_placeholder = true;
          ways.push(pseudoWay);
        }
        function fullGeometryWay(way, nds) {
          function addFullGeometryNode(lat, lon, id) {
            var geometryNode = {
              type: "node",
              id,
              lat,
              lon
            };
            nodes.push(geometryNode);
            return geometryNode.id;
          }
          if (!_.isArray(way.nodes)) {
            way.nodes = [];
            _.each(nds, function(nd, i) {
              way.nodes.push("_anonymous@" + nd.getAttribute("lat") + "/" + nd.getAttribute("lon"));
            });
          }
          _.each(nds, function(nd, i) {
            if (nd.getAttribute("lat")) {
              addFullGeometryNode(
                nd.getAttribute("lat"),
                nd.getAttribute("lon"),
                way.nodes[i]
              );
            }
          });
        }
        function fullGeometryRelation(rel, members) {
          function addFullGeometryNode(lat, lon, id) {
            var geometryNode = {
              type: "node",
              id,
              lat,
              lon
            };
            nodes.push(geometryNode);
          }
          function addFullGeometryWay(nds, id) {
            if (ways.some(function(way) {
              return way.type == "way" && way.id == id;
            }))
              return;
            var geometryWay = {
              type: "way",
              id,
              nodes: []
            };
            function addFullGeometryWayPseudoNode(lat, lon) {
              var geometryPseudoNode = {
                type: "node",
                id: "_anonymous@" + lat + "/" + lon,
                lat,
                lon
              };
              geometryWay.nodes.push(geometryPseudoNode.id);
              nodes.push(geometryPseudoNode);
            }
            _.each(nds, function(nd) {
              if (nd.getAttribute("lat")) {
                addFullGeometryWayPseudoNode(
                  nd.getAttribute("lat"),
                  nd.getAttribute("lon")
                );
              } else {
                geometryWay.nodes.push(void 0);
              }
            });
            ways.push(geometryWay);
          }
          _.each(members, function(member, i) {
            if (rel.members[i].type == "node") {
              if (member.getAttribute("lat")) {
                addFullGeometryNode(
                  member.getAttribute("lat"),
                  member.getAttribute("lon"),
                  rel.members[i].ref
                );
              }
            } else if (rel.members[i].type == "way") {
              if (member.getElementsByTagName("nd").length > 0) {
                rel.members[i].ref = "_fullGeom" + rel.members[i].ref;
                addFullGeometryWay(
                  member.getElementsByTagName("nd"),
                  rel.members[i].ref
                );
              }
            }
          });
        }
        _.each(xml.getElementsByTagName("node"), function(node, i) {
          var tags = {};
          _.each(node.getElementsByTagName("tag"), function(tag) {
            tags[tag.getAttribute("k")] = tag.getAttribute("v");
          });
          var nodeObject = {
            "type": "node"
          };
          copy_attribute(node, nodeObject, "id");
          copy_attribute(node, nodeObject, "lat");
          copy_attribute(node, nodeObject, "lon");
          copy_attribute(node, nodeObject, "version");
          copy_attribute(node, nodeObject, "timestamp");
          copy_attribute(node, nodeObject, "changeset");
          copy_attribute(node, nodeObject, "uid");
          copy_attribute(node, nodeObject, "user");
          if (!_.isEmpty(tags))
            nodeObject.tags = tags;
          nodes.push(nodeObject);
        });
        var centroid, bounds;
        _.each(xml.getElementsByTagName("way"), function(way, i) {
          var tags = {};
          var wnodes = [];
          _.each(way.getElementsByTagName("tag"), function(tag) {
            tags[tag.getAttribute("k")] = tag.getAttribute("v");
          });
          var has_full_geometry = false;
          _.each(way.getElementsByTagName("nd"), function(nd, i2) {
            var id;
            if (id = nd.getAttribute("ref"))
              wnodes[i2] = id;
            if (!has_full_geometry && nd.getAttribute("lat"))
              has_full_geometry = true;
          });
          var wayObject = {
            "type": "way"
          };
          copy_attribute(way, wayObject, "id");
          copy_attribute(way, wayObject, "version");
          copy_attribute(way, wayObject, "timestamp");
          copy_attribute(way, wayObject, "changeset");
          copy_attribute(way, wayObject, "uid");
          copy_attribute(way, wayObject, "user");
          if (wnodes.length > 0)
            wayObject.nodes = wnodes;
          if (!_.isEmpty(tags))
            wayObject.tags = tags;
          if (centroid = way.getElementsByTagName("center")[0])
            centerGeometry(wayObject, centroid);
          if (has_full_geometry)
            fullGeometryWay(wayObject, way.getElementsByTagName("nd"));
          else if (bounds = way.getElementsByTagName("bounds")[0])
            boundsGeometry(wayObject, bounds);
          ways.push(wayObject);
        });
        _.each(xml.getElementsByTagName("relation"), function(relation, i) {
          var tags = {};
          var members = [];
          _.each(relation.getElementsByTagName("tag"), function(tag) {
            tags[tag.getAttribute("k")] = tag.getAttribute("v");
          });
          var has_full_geometry = false;
          _.each(relation.getElementsByTagName("member"), function(member, i2) {
            members[i2] = {};
            copy_attribute(member, members[i2], "ref");
            copy_attribute(member, members[i2], "role");
            copy_attribute(member, members[i2], "type");
            if (!has_full_geometry && (members[i2].type == "node" && member.getAttribute("lat")) || members[i2].type == "way" && member.getElementsByTagName("nd").length > 0)
              has_full_geometry = true;
          });
          var relObject = {
            "type": "relation"
          };
          copy_attribute(relation, relObject, "id");
          copy_attribute(relation, relObject, "version");
          copy_attribute(relation, relObject, "timestamp");
          copy_attribute(relation, relObject, "changeset");
          copy_attribute(relation, relObject, "uid");
          copy_attribute(relation, relObject, "user");
          if (members.length > 0)
            relObject.members = members;
          if (!_.isEmpty(tags))
            relObject.tags = tags;
          if (centroid = relation.getElementsByTagName("center")[0])
            centerGeometry(relObject, centroid);
          if (has_full_geometry)
            fullGeometryRelation(relObject, relation.getElementsByTagName("member"));
          else if (bounds = relation.getElementsByTagName("bounds")[0])
            boundsGeometry(relObject, bounds);
          rels.push(relObject);
        });
        return _convert2geoJSON(nodes, ways, rels);
      }
      function _convert2geoJSON(nodes, ways, rels) {
        function has_interesting_tags(t, ignore_tags) {
          if (typeof ignore_tags !== "object")
            ignore_tags = {};
          if (typeof options.uninterestingTags === "function")
            return !options.uninterestingTags(t, ignore_tags);
          for (var k in t)
            if (!(options.uninterestingTags[k] === true) && !(ignore_tags[k] === true || ignore_tags[k] === t[k]))
              return true;
          return false;
        }
        ;
        function build_meta_information(object) {
          var res = {
            "timestamp": object.timestamp,
            "version": object.version,
            "changeset": object.changeset,
            "user": object.user,
            "uid": object.uid
          };
          for (var k in res)
            if (res[k] === void 0)
              delete res[k];
          return res;
        }
        var nodeids = new Object();
        var poinids = new Object();
        for (var i = 0; i < nodes.length; i++) {
          var node = nodes[i];
          if (nodeids[node.id] !== void 0) {
            node = options.deduplicator(node, nodeids[node.id]);
          }
          nodeids[node.id] = node;
          if (typeof node.tags != "undefined" && has_interesting_tags(node.tags))
            poinids[node.id] = true;
        }
        for (var i = 0; i < rels.length; i++) {
          if (_.isArray(rels[i].members)) {
            for (var j = 0; j < rels[i].members.length; j++) {
              if (rels[i].members[j].type == "node")
                poinids[rels[i].members[j].ref] = true;
            }
          }
        }
        var wayids = new Object();
        var waynids = new Object();
        for (var i = 0; i < ways.length; i++) {
          var way = ways[i];
          if (wayids[way.id]) {
            way = options.deduplicator(way, wayids[way.id]);
          }
          wayids[way.id] = way;
          if (_.isArray(way.nodes)) {
            for (var j = 0; j < way.nodes.length; j++) {
              if (typeof way.nodes[j] === "object")
                continue;
              waynids[way.nodes[j]] = true;
              way.nodes[j] = nodeids[way.nodes[j]];
            }
          }
        }
        var pois = new Array();
        for (var id in nodeids) {
          var node = nodeids[id];
          if (!waynids[id] || poinids[id])
            pois.push(node);
        }
        var relids = new Array();
        for (var i = 0; i < rels.length; i++) {
          var rel = rels[i];
          if (relids[rel.id]) {
            rel = options.deduplicator(rel, relids[rel.id]);
          }
          relids[rel.id] = rel;
        }
        var relsmap = { node: {}, way: {}, relation: {} };
        for (var id in relids) {
          var rel = relids[id];
          if (!_.isArray(rel.members)) {
            if (options.verbose)
              console.warn("Relation", rel.type + "/" + rel.id, "ignored because it has no members");
            continue;
          }
          for (var j = 0; j < rel.members.length; j++) {
            var m_type = rel.members[j].type;
            var m_ref = rel.members[j].ref;
            if (typeof m_ref !== "number") {
              m_ref = m_ref.replace("_fullGeom", "");
            }
            if (!relsmap[m_type]) {
              if (options.verbose)
                console.warn("Relation", rel.type + "/" + rel.id, "member", m_type + "/" + m_ref, "ignored because it has an invalid type");
              continue;
            }
            if (typeof relsmap[m_type][m_ref] === "undefined")
              relsmap[m_type][m_ref] = [];
            relsmap[m_type][m_ref].push({
              "role": rel.members[j].role,
              "rel": rel.id,
              "reltags": rel.tags
            });
          }
        }
        var geojson;
        var geojsonnodes = [];
        for (i = 0; i < pois.length; i++) {
          if (typeof pois[i].lon == "undefined" || typeof pois[i].lat == "undefined") {
            if (options.verbose)
              console.warn("POI", pois[i].type + "/" + pois[i].id, "ignored because it lacks coordinates");
            continue;
          }
          var feature = {
            "type": "Feature",
            "id": pois[i].type + "/" + pois[i].id,
            "properties": {
              "type": pois[i].type,
              "id": pois[i].id,
              "tags": pois[i].tags || {},
              "relations": relsmap["node"][pois[i].id] || [],
              "meta": build_meta_information(pois[i])
            },
            "geometry": {
              "type": "Point",
              "coordinates": [+pois[i].lon, +pois[i].lat]
            }
          };
          if (pois[i].__is_center_placeholder)
            feature.properties["geometry"] = "center";
          if (!featureCallback)
            geojsonnodes.push(feature);
          else
            featureCallback(feature);
        }
        var geojsonlines = [];
        var geojsonpolygons = [];
        for (var i = 0; i < rels.length; i++) {
          if (relids[rels[i].id] !== rels[i]) {
            continue;
          }
          if (typeof rels[i].tags != "undefined" && (rels[i].tags["type"] == "route" || rels[i].tags["type"] == "waterway")) {
            let construct_multilinestring2 = function(rel2) {
              var is_tainted = false;
              var members;
              members = rel2.members.filter(function(m) {
                return m.type === "way";
              });
              members = members.map(function(m) {
                var way2 = wayids[m.ref];
                if (way2 === void 0 || way2.nodes === void 0) {
                  if (options.verbose)
                    console.warn("Route " + rel2.type + "/" + rel2.id, "tainted by a missing or incomplete  way", m.type + "/" + m.ref);
                  is_tainted = true;
                  return;
                }
                return {
                  // TODO: this is slow! :(
                  id: m.ref,
                  role: m.role,
                  way: way2,
                  nodes: way2.nodes.filter(function(n) {
                    if (n !== void 0)
                      return true;
                    is_tainted = true;
                    if (options.verbose)
                      console.warn("Route", rel2.type + "/" + rel2.id, "tainted by a way", m.type + "/" + m.ref, "with a missing node");
                    return false;
                  })
                };
              });
              members = _.compact(members);
              var linestrings;
              linestrings = join(members);
              var coords2 = [];
              coords2 = _.compact(linestrings.map(function(linestring) {
                return _.compact(linestring.map(function(node2) {
                  return [+node2.lon, +node2.lat];
                }));
              }));
              if (coords2.length == 0) {
                if (options.verbose)
                  console.warn("Route", rel2.type + "/" + rel2.id, "contains no coordinates");
                return false;
              }
              var feature2 = {
                "type": "Feature",
                "id": rel2.type + "/" + rel2.id,
                "properties": {
                  "type": rel2.type,
                  "id": rel2.id,
                  "tags": rel2.tags || {},
                  "relations": relsmap[rel2.type][rel2.id] || [],
                  "meta": build_meta_information(rel2)
                },
                "geometry": {
                  "type": coords2.length === 1 ? "LineString" : "MultiLineString",
                  "coordinates": coords2.length === 1 ? coords2[0] : coords2
                }
              };
              if (is_tainted) {
                if (options.verbose)
                  console.warn("Route", rel2.type + "/" + rel2.id, "is tainted");
                feature2.properties["tainted"] = true;
              }
              return feature2;
            };
            var construct_multilinestring = construct_multilinestring2;
            if (!_.isArray(rels[i].members)) {
              if (options.verbose)
                console.warn("Route", rels[i].type + "/" + rels[i].id, "ignored because it has no members");
              continue;
            }
            rels[i].members.forEach(function(m) {
              if (wayids[m.ref] && !has_interesting_tags(wayids[m.ref].tags))
                wayids[m.ref].is_skippablerelationmember = true;
            });
            feature = construct_multilinestring2(rels[i]);
            if (feature === false) {
              if (options.verbose)
                console.warn("Route relation", rels[i].type + "/" + rels[i].id, "ignored because it has invalid geometry");
              continue;
            }
            if (!featureCallback)
              geojsonpolygons.push(feature);
            else
              featureCallback(rewind(feature));
          }
          if (typeof rels[i].tags != "undefined" && (rels[i].tags["type"] == "multipolygon" || rels[i].tags["type"] == "boundary")) {
            let construct_multipolygon2 = function(tag_object, rel2) {
              var is_tainted = false;
              var mp_geometry = simple_mp ? "way" : "relation", mp_id = typeof tag_object.id === "number" ? tag_object.id : +tag_object.id.replace("_fullGeom", "");
              var members;
              members = rel2.members.filter(function(m) {
                return m.type === "way";
              });
              members = members.map(function(m) {
                var way2 = wayids[m.ref];
                if (way2 === void 0 || way2.nodes === void 0) {
                  if (options.verbose)
                    console.warn("Multipolygon", mp_geometry + "/" + mp_id, "tainted by a missing or incomplete way", m.type + "/" + m.ref);
                  is_tainted = true;
                  return;
                }
                return {
                  // TODO: this is slow! :(
                  id: m.ref,
                  role: m.role || "outer",
                  way: way2,
                  nodes: way2.nodes.filter(function(n) {
                    if (n !== void 0)
                      return true;
                    is_tainted = true;
                    if (options.verbose)
                      console.warn("Multipolygon", mp_geometry + "/" + mp_id, "tainted by a way", m.type + "/" + m.ref, "with a missing node");
                    return false;
                  })
                };
              });
              members = _.compact(members);
              var outers, inners;
              outers = join(members.filter(function(m) {
                return m.role === "outer";
              }));
              inners = join(members.filter(function(m) {
                return m.role === "inner";
              }));
              var mp;
              function findOuter(inner) {
                var polygonIntersectsPolygon = function(outer2, inner2) {
                  for (var i2 = 0; i2 < inner2.length; i2++)
                    if (pointInPolygon(inner2[i2], outer2))
                      return true;
                  return false;
                };
                var mapCoordinates = function(from) {
                  return from.map(function(n) {
                    return [+n.lat, +n.lon];
                  });
                };
                var pointInPolygon = function(point, polygon) {
                  var x = point[0], y = point[1], inside = false;
                  for (var i2 = 0, j3 = polygon.length - 1; i2 < polygon.length; j3 = i2++) {
                    var xi = polygon[i2][0], yi = polygon[i2][1];
                    var xj = polygon[j3][0], yj = polygon[j3][1];
                    var intersect = yi > y != yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
                    if (intersect)
                      inside = !inside;
                  }
                  return inside;
                };
                var o2, outer;
                inner = mapCoordinates(inner);
                for (o2 = 0; o2 < outers.length; o2++) {
                  outer = mapCoordinates(outers[o2]);
                  if (polygonIntersectsPolygon(outer, inner))
                    return o2;
                }
              }
              mp = outers.map(function(o2) {
                return [o2];
              });
              for (var j2 = 0; j2 < inners.length; j2++) {
                var o = findOuter(inners[j2]);
                if (o !== void 0)
                  mp[o].push(inners[j2]);
                else if (options.verbose)
                  console.warn("Multipolygon", mp_geometry + "/" + mp_id, "contains an inner ring with no containing outer");
                ;
              }
              var mp_coords = [];
              mp_coords = _.compact(mp.map(function(cluster) {
                var cl = _.compact(cluster.map(function(ring) {
                  if (ring.length < 4) {
                    if (options.verbose)
                      console.warn("Multipolygon", mp_geometry + "/" + mp_id, "contains a ring with less than four nodes");
                    return;
                  }
                  return _.compact(ring.map(function(node2) {
                    return [+node2.lon, +node2.lat];
                  }));
                }));
                if (cl.length == 0) {
                  if (options.verbose)
                    console.warn("Multipolygon", mp_geometry + "/" + mp_id, "contains an empty ring cluster");
                  return;
                }
                return cl;
              }));
              if (mp_coords.length == 0) {
                if (options.verbose)
                  console.warn("Multipolygon", mp_geometry + "/" + mp_id, "contains no coordinates");
                return false;
              }
              var mp_type = "MultiPolygon";
              if (mp_coords.length === 1) {
                mp_type = "Polygon";
                mp_coords = mp_coords[0];
              }
              var feature2 = {
                "type": "Feature",
                "id": tag_object.type + "/" + mp_id,
                "properties": {
                  "type": tag_object.type,
                  "id": mp_id,
                  "tags": tag_object.tags || {},
                  "relations": relsmap[tag_object.type][tag_object.id] || [],
                  "meta": build_meta_information(tag_object)
                },
                "geometry": {
                  "type": mp_type,
                  "coordinates": mp_coords
                }
              };
              if (is_tainted) {
                if (options.verbose)
                  console.warn("Multipolygon", mp_geometry + "/" + mp_id, "is tainted");
                feature2.properties["tainted"] = true;
              }
              return feature2;
            };
            var construct_multipolygon = construct_multipolygon2;
            if (!_.isArray(rels[i].members)) {
              if (options.verbose)
                console.warn("Multipolygon", rels[i].type + "/" + rels[i].id, "ignored because it has no members");
              continue;
            }
            var outer_count = 0;
            for (var j = 0; j < rels[i].members.length; j++)
              if (rels[i].members[j].role == "outer")
                outer_count++;
              else if (options.verbose && rels[i].members[j].role != "inner")
                console.warn("Multipolygon", rels[i].type + "/" + rels[i].id, "member", rels[i].members[j].type + "/" + rels[i].members[j].ref, 'ignored because it has an invalid role: "' + rels[i].members[j].role + '"');
            rels[i].members.forEach(function(m) {
              if (wayids[m.ref]) {
                if (m.role === "outer" && !has_interesting_tags(wayids[m.ref].tags, rels[i].tags))
                  wayids[m.ref].is_skippablerelationmember = true;
                if (m.role === "inner" && !has_interesting_tags(wayids[m.ref].tags))
                  wayids[m.ref].is_skippablerelationmember = true;
              }
            });
            if (outer_count == 0) {
              if (options.verbose)
                console.warn("Multipolygon relation", rels[i].type + "/" + rels[i].id, "ignored because it has no outer ways");
              continue;
            }
            var simple_mp = false;
            if (outer_count == 1 && !has_interesting_tags(rels[i].tags, { "type": true }))
              simple_mp = true;
            var feature = null;
            if (!simple_mp) {
              feature = construct_multipolygon2(rels[i], rels[i]);
            } else {
              var outer_way = rels[i].members.filter(function(m) {
                return m.role === "outer";
              })[0];
              outer_way = wayids[outer_way.ref];
              if (outer_way === void 0) {
                if (options.verbose)
                  console.warn("Multipolygon relation", rels[i].type + "/" + rels[i].id, "ignored because outer way", outer_way.type + "/" + outer_way.ref, "is missing");
                continue;
              }
              outer_way.is_skippablerelationmember = true;
              feature = construct_multipolygon2(outer_way, rels[i]);
            }
            if (feature === false) {
              if (options.verbose)
                console.warn("Multipolygon relation", rels[i].type + "/" + rels[i].id, "ignored because it has invalid geometry");
              continue;
            }
            if (!featureCallback)
              geojsonpolygons.push(feature);
            else
              featureCallback(rewind(feature));
          }
        }
        for (var i = 0; i < ways.length; i++) {
          if (wayids[ways[i].id] !== ways[i]) {
            continue;
          }
          if (!_.isArray(ways[i].nodes)) {
            if (options.verbose)
              console.warn("Way", ways[i].type + "/" + ways[i].id, "ignored because it has no nodes");
            continue;
          }
          if (ways[i].is_skippablerelationmember)
            continue;
          if (typeof ways[i].id !== "number") {
            ways[i].id = +ways[i].id.replace("_fullGeom", "");
          }
          ways[i].tainted = false;
          ways[i].hidden = false;
          var coords = new Array();
          for (j = 0; j < ways[i].nodes.length; j++) {
            if (typeof ways[i].nodes[j] == "object")
              coords.push([+ways[i].nodes[j].lon, +ways[i].nodes[j].lat]);
            else {
              if (options.verbose)
                console.warn("Way", ways[i].type + "/" + ways[i].id, "is tainted by an invalid node");
              ways[i].tainted = true;
            }
          }
          if (coords.length <= 1) {
            if (options.verbose)
              console.warn("Way", ways[i].type + "/" + ways[i].id, "ignored because it contains too few nodes");
            continue;
          }
          var way_type = "LineString";
          if (typeof ways[i].nodes[0] != "undefined" && typeof ways[i].nodes[ways[i].nodes.length - 1] != "undefined" && // way has its start/end nodes loaded
          ways[i].nodes[0].id === ways[i].nodes[ways[i].nodes.length - 1].id && // ... and forms a closed ring
          (typeof ways[i].tags != "undefined" && // ... and has tags
          _isPolygonFeature(ways[i].tags) || // or is a placeholder for a bounds geometry
          ways[i].__is_bounds_placeholder)) {
            way_type = "Polygon";
            coords = [coords];
          }
          var feature = {
            "type": "Feature",
            "id": ways[i].type + "/" + ways[i].id,
            "properties": {
              "type": ways[i].type,
              "id": ways[i].id,
              "tags": ways[i].tags || {},
              "relations": relsmap["way"][ways[i].id] || [],
              "meta": build_meta_information(ways[i])
            },
            "geometry": {
              "type": way_type,
              "coordinates": coords
            }
          };
          if (ways[i].tainted) {
            if (options.verbose)
              console.warn("Way", ways[i].type + "/" + ways[i].id, "is tainted");
            feature.properties["tainted"] = true;
          }
          if (ways[i].__is_bounds_placeholder)
            feature.properties["geometry"] = "bounds";
          if (!featureCallback) {
            if (way_type == "LineString")
              geojsonlines.push(feature);
            else
              geojsonpolygons.push(feature);
          } else {
            featureCallback(rewind(feature));
          }
        }
        if (featureCallback)
          return true;
        geojson = {
          "type": "FeatureCollection",
          "features": []
        };
        geojson.features = geojson.features.concat(geojsonpolygons);
        geojson.features = geojson.features.concat(geojsonlines);
        geojson.features = geojson.features.concat(geojsonnodes);
        if (options.flatProperties) {
          geojson.features.forEach(function(f) {
            f.properties = _.merge(
              f.properties.meta,
              f.properties.tags,
              { id: f.properties.type + "/" + f.properties.id }
            );
          });
        }
        geojson = rewind(geojson);
        return geojson;
      }
      function _isPolygonFeature(tags) {
        var polygonFeatures2 = options.polygonFeatures;
        if (typeof polygonFeatures2 === "function")
          return polygonFeatures2(tags);
        if (tags["area"] === "no")
          return false;
        for (var key in tags) {
          var val = tags[key];
          var pfk = polygonFeatures2[key];
          if (typeof pfk === "undefined")
            continue;
          if (val === "no")
            continue;
          if (pfk === true)
            return true;
          if (pfk.included_values && pfk.included_values[val] === true)
            return true;
          if (pfk.excluded_values && pfk.excluded_values[val] !== true)
            return true;
        }
        return false;
      }
    };
    function join(ways) {
      var _first = function(arr) {
        return arr[0];
      };
      var _last = function(arr) {
        return arr[arr.length - 1];
      };
      var _fitTogether = function(n1, n2) {
        return n1 !== void 0 && n2 !== void 0 && n1.id === n2.id;
      };
      var joined = [], current, first, last, i, how, what;
      while (ways.length) {
        current = ways.pop().nodes.slice();
        joined.push(current);
        while (ways.length && !_fitTogether(_first(current), _last(current))) {
          first = _first(current);
          last = _last(current);
          for (i = 0; i < ways.length; i++) {
            what = ways[i].nodes;
            if (_fitTogether(last, _first(what))) {
              how = current.push;
              what = what.slice(1);
              break;
            } else if (_fitTogether(last, _last(what))) {
              how = current.push;
              what = what.slice(0, -1).reverse();
              break;
            } else if (_fitTogether(first, _last(what))) {
              how = current.unshift;
              what = what.slice(0, -1);
              break;
            } else if (_fitTogether(first, _first(what))) {
              how = current.unshift;
              what = what.slice(1).reverse();
              break;
            } else {
              what = how = null;
            }
          }
          if (!what)
            break;
          ways.splice(i, 1);
          how.apply(current, what);
        }
      }
      return joined;
    }
    osmtogeojson.toGeojson = osmtogeojson;
    module.exports = osmtogeojson;
  }
});
export default require_osmtogeojson();
/*! Bundled license information:

osmtogeojson/lodash.custom.js:
  (**
   * @license
   * lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash exports="node" include="clone,merge,isEmpty,isArray,compact,each" -d`
   * Copyright jQuery Foundation and other contributors <https://jquery.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)
*/
//# sourceMappingURL=osmtogeojson.js.map
